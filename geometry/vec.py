"""Basic type definitions used for type annotations."""
from __future__ import annotations

import math
from collections import abc
from typing import Any, Sequence, Tuple, TypeVar, Union, overload

import attrs
import numpy as np
from typeguard import typechecked
from typing_extensions import TypeGuard

BuiltinInt = int
BuiltinFloat = float

T = TypeVar("T", bound=float)

VEC3D_PRECISION = 10


@attrs.frozen(init=False)
@typechecked
class Vec3D(abc.Sequence[T]):
    """
    Primitive for an 3-dimensional vector.  Code for other dimensionalities will be autogenerated.
    """

    x: T
    y: T
    z: T

    # TODO: Support type inference for np.generic types
    def __init__(self, x: T | np.generic, y: T | np.generic, z: T | np.generic):
        if isinstance(x, np.generic):
            object.__setattr__(self, "x", x.item())
        else:
            object.__setattr__(self, "x", x)

        if isinstance(y, np.generic):
            object.__setattr__(self, "y", y.item())
        else:
            object.__setattr__(self, "y", y)

        if isinstance(z, np.generic):
            object.__setattr__(self, "z", z.item())
        else:
            object.__setattr__(self, "z", z)

    @property
    def vec(self) -> tuple[T, T, T]:
        return (self.x, self.y, self.z)

    @overload
    def __getitem__(self, key: BuiltinInt) -> T:
        ...

    @overload
    def __getitem__(self, key: slice) -> Tuple[T, ...]:
        ...

    def __getitem__(self, key):
        return self.vec[key]

    def __iter__(self):
        return self.vec.__iter__()

    def __len__(self) -> BuiltinInt:
        return 3

    def __lt__(self, other) -> bool:
        return all(s < o for (s, o) in zip(self.vec, other.vec))

    def __le__(self, other) -> bool:
        return all(s <= o for (s, o) in zip(self.vec, other.vec))

    def __gt__(self, other) -> bool:
        return all(s > o for (s, o) in zip(self.vec, other.vec))

    def __ge__(self, other) -> bool:
        return all(s >= o for (s, o) in zip(self.vec, other.vec))

    def isclose(
        self,
        other: Vec3D | BuiltinFloat | BuiltinInt,
        *,
        rel_tol: BuiltinFloat = 1e-05,
        abs_tol: BuiltinFloat = 1e-08,
    ) -> Tuple[bool, bool, bool]:
        if isinstance(other, Vec3D):
            return (
                math.isclose(self.x, other.x, rel_tol=rel_tol, abs_tol=abs_tol),
                math.isclose(self.y, other.y, rel_tol=rel_tol, abs_tol=abs_tol),
                math.isclose(self.z, other.z, rel_tol=rel_tol, abs_tol=abs_tol),
            )
        else:
            return (
                math.isclose(self.x, other, rel_tol=rel_tol, abs_tol=abs_tol),
                math.isclose(self.y, other, rel_tol=rel_tol, abs_tol=abs_tol),
                math.isclose(self.z, other, rel_tol=rel_tol, abs_tol=abs_tol),
            )

    def allclose(
        self,
        other: Vec3D | BuiltinFloat | BuiltinInt,
        *,
        rel_tol: BuiltinFloat = 1e-05,
        abs_tol: BuiltinFloat = 1e-08,
    ) -> bool:
        return all(self.isclose(other, rel_tol=rel_tol, abs_tol=abs_tol))

    def __repr__(self) -> str:
        return f"Vec3D({', '.join(str(e) for e in self)})"

    def __truediv__(self, other: Vec3D | BuiltinFloat) -> Vec3D[BuiltinFloat]:
        if isinstance(other, (BuiltinFloat, BuiltinInt)):
            return Vec3D[BuiltinFloat](*(e / other for e in self))
        else:
            return Vec3D[BuiltinFloat](*(e / f for (e, f) in zip(self, other)))

    def __rtruediv__(self, other: BuiltinFloat) -> Vec3D[BuiltinFloat]:
        return Vec3D[BuiltinFloat](*(other / e for e in self))

    def __neg__(self) -> Vec3D[T]:
        return Vec3D[T](*(-e for e in self))

    def __abs__(self) -> Vec3D[T]:
        return Vec3D[T](*(abs(e) for e in self))

    @overload
    def __round__(self) -> Vec3D[BuiltinInt]:
        ...

    @overload
    def __round__(self, ndigits: int) -> Vec3D[T]:
        ...

    def __round__(self, ndigits: int | None = None):
        if ndigits is None:
            return Vec3D[BuiltinInt](*(round(e) for e in self))
        return Vec3D[T](*(round(e, ndigits) for e in self))

    def __floor__(self) -> Vec3D[BuiltinInt]:
        return Vec3D[BuiltinInt](*(math.floor(e) for e in self))

    def __ceil__(self) -> Vec3D[BuiltinInt]:
        return Vec3D[BuiltinInt](*(math.ceil(e) for e in self))

    def __trunc__(self) -> Vec3D[BuiltinInt]:
        return Vec3D[BuiltinInt](*(math.trunc(e) for e in self))

    @overload
    def __add__(self, other: Union[Vec3D[BuiltinInt], BuiltinInt]) -> Vec3D[T]:
        ...

    @overload
    def __add__(self, other: Union[Vec3D[BuiltinFloat], BuiltinFloat]) -> Vec3D[BuiltinFloat]:
        ...

    def __add__(self, other: Vec3D | BuiltinInt | BuiltinFloat):
        if isinstance(other, BuiltinInt):
            return Vec3D[T](*(e + other for e in self))
        elif isinstance(other, BuiltinFloat):
            return Vec3D[BuiltinFloat](*(e + other for e in self))
        elif is_int_vec(other):
            return Vec3D[T](*(e + f for (e, f) in zip(self, other)))  # type: ignore
        else:
            return Vec3D[T](*(e + f for (e, f) in zip(self, other)))

    @overload
    def __radd__(self, other: BuiltinInt) -> Vec3D[T]:
        ...

    @overload
    def __radd__(self, other: BuiltinFloat) -> Vec3D[BuiltinFloat]:
        ...

    def __radd__(self, other):
        if isinstance(other, BuiltinInt):
            return Vec3D[T](*(other + e for e in self))
        else:
            return Vec3D[BuiltinFloat](*(other + e for e in self))

    @overload
    def __sub__(self, other: Union[Vec3D[BuiltinInt], BuiltinInt]) -> Vec3D[T]:
        ...

    @overload
    def __sub__(self, other: Union[Vec3D[BuiltinFloat], BuiltinFloat]) -> Vec3D[BuiltinFloat]:
        ...

    def __sub__(self, other):
        if isinstance(other, (BuiltinInt)):
            return Vec3D[T](*(e - other for e in self))
        elif isinstance(other, (BuiltinFloat)):
            return Vec3D[BuiltinFloat](*(e - other for e in self))
        elif is_int_vec(other):
            return Vec3D[T](*(e - f for (e, f) in zip(self, other)))  # type: ignore
        else:
            return Vec3D[BuiltinFloat](*(e - f for (e, f) in zip(self, other)))

    @overload
    def __rsub__(self, other: BuiltinInt) -> Vec3D[T]:
        ...

    @overload
    def __rsub__(self, other: BuiltinFloat) -> Vec3D[BuiltinFloat]:
        ...

    def __rsub__(self, other):
        if isinstance(other, BuiltinInt):
            return Vec3D[T](*(other - e for e in self))
        else:
            return Vec3D[BuiltinFloat](*(other - e for e in self))

    @overload
    def __mul__(self, other: Union[Vec3D[BuiltinInt], BuiltinInt]) -> Vec3D[T]:
        ...

    @overload
    def __mul__(self, other: Union[Vec3D[BuiltinFloat], BuiltinFloat]) -> Vec3D[BuiltinFloat]:
        ...

    def __mul__(self, other):
        if isinstance(other, (BuiltinInt)):
            return Vec3D[T](*(e * other for e in self))
        elif isinstance(other, (BuiltinFloat)):
            return Vec3D[BuiltinFloat](*(e * other for e in self))
        elif is_int_vec(other):
            return Vec3D[T](*(e * f for (e, f) in zip(self, other)))  # type: ignore
        else:
            return Vec3D[BuiltinFloat](*(e * f for (e, f) in zip(self, other)))

    @overload
    def __rmul__(self, other: BuiltinInt) -> Vec3D[T]:
        ...

    @overload
    def __rmul__(self, other: BuiltinFloat) -> Vec3D[BuiltinFloat]:
        ...

    def __rmul__(self, other):
        if isinstance(other, BuiltinInt):
            return Vec3D[T](*(other * e for e in self))
        else:
            return Vec3D[BuiltinFloat](*(other * e for e in self))

    @overload
    def __floordiv__(self, other: Union[Vec3D[BuiltinInt], BuiltinInt]) -> Vec3D[T]:
        ...

    @overload
    def __floordiv__(self, other: Union[Vec3D[BuiltinFloat], BuiltinFloat]) -> Vec3D[BuiltinFloat]:
        ...

    def __floordiv__(self, other):
        if isinstance(other, (BuiltinFloat, BuiltinInt)):
            return Vec3D[BuiltinInt](*(e // other for e in self))
        return Vec3D[BuiltinInt](*(e // f for (e, f) in zip(self, other)))

    @overload
    def __rfloordiv__(self, other: BuiltinInt) -> Vec3D[T]:
        ...

    @overload
    def __rfloordiv__(self, other: BuiltinFloat) -> Vec3D[BuiltinFloat]:
        ...

    def __rfloordiv__(self, other):
        return Vec3D[BuiltinInt](*(other // e for e in self))

    @overload
    def __mod__(self, other: Union[Vec3D[BuiltinInt], BuiltinInt]) -> Vec3D[T]:
        ...

    @overload
    def __mod__(self, other: Union[Vec3D[BuiltinFloat], BuiltinFloat]) -> Vec3D[BuiltinFloat]:
        ...

    def __mod__(self, other):
        if isinstance(other, (BuiltinInt)):
            return Vec3D[T](*(e % other for e in self))
        elif isinstance(other, (BuiltinFloat)):
            return Vec3D[BuiltinFloat](*(e % other for e in self))
        elif is_int_vec(other):
            return Vec3D[T](*(e % f for (e, f) in zip(self, other)))  # type: ignore
        else:
            return Vec3D[BuiltinFloat](*(e % f for (e, f) in zip(self, other)))

    @overload
    def __rmod__(self, other: BuiltinInt) -> Vec3D[T]:
        ...

    @overload
    def __rmod__(self, other: BuiltinFloat) -> Vec3D[BuiltinFloat]:
        ...

    def __rmod__(self, other):
        if isinstance(other, BuiltinInt):
            return Vec3D[T](*(other % e for e in self))
        else:
            return Vec3D[BuiltinFloat](*(other % e for e in self))

    def int(self) -> Vec3D[BuiltinInt]:
        return Vec3D[BuiltinInt](*(BuiltinInt(arg) for arg in self.vec))

    def float(self) -> Vec3D[BuiltinFloat]:
        return Vec3D[BuiltinFloat](*(BuiltinFloat(arg) for arg in self.vec))

    def pformat(self) -> str:  # pragma: no cover
        return str(tuple(self))


@typechecked
def isclose(
    a: Vec3D,
    b: Vec3D | BuiltinFloat | BuiltinInt,
    *,
    rel_tol: BuiltinFloat = 1e-05,
    abs_tol: BuiltinFloat = 1e-08,
) -> Tuple[bool, bool, bool]:
    return a.isclose(b, rel_tol=rel_tol, abs_tol=abs_tol)


@typechecked
def allclose(
    a: Vec3D,
    b: Vec3D | BuiltinFloat | BuiltinInt,
    *,
    rel_tol: BuiltinFloat = 1e-05,
    abs_tol: BuiltinFloat = 1e-08,
) -> bool:
    return a.allclose(b, rel_tol=rel_tol, abs_tol=abs_tol)


@typechecked
def is_int_vec(vec: Vec3D) -> TypeGuard[Vec3D[int]]:
    return all(isinstance(v, int) for v in vec.vec)


"""
def convert_list3_to_vec3d(value: Any, recursive=True) -> Any:
    result: Any
    if is_raw_vec3d(value):
        result = Vec3D(*value)
    elif not recursive:
        result = value
    else:
        if isinstance(value, dict):
            result = {
                k: convert_list3_to_vec3d(v, recursive=True)
                for k, v in value.items()
            }
        elif isinstance(value, list):
            result = [convert_list3_to_vec3d(v, recursive=True) for v in value]
        elif isinstance(value, list):
            result = [convert_list3_to_vec3d(v, recursive=True) for v in value]
        else:
            result = value
    return result
"""


def is_raw_vec3d(value: Any) -> TypeGuard[RawVec3D]:  # pragma: no cover
    return isinstance(value, Vec3D) or (
        isinstance(value, Sequence)
        and len(value) == 3
        and all(isinstance(e, (int, float)) for e in value)
    )


IntVec3D = Vec3D[int]

RawVec3D = Union[
    Vec3D[T],
    tuple[T, T, T],
    list[T],
]
